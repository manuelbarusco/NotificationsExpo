<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.android.notificationexpo">


    <!--Permission usata nel boradcast (più informazioni in fondo al file)-->
    <permission
        android:name="com.android.notificationexpo.PRIVATE"
        android:protectionLevel="signature"/>
    <!--Acquisisco la permission appena dichiarata-->
    <uses-permission
        android:name="com.android.NotificationsExpo.PRIVATE"/>



    <!--
    Since API level 28, apps wanting to use foreground services must request the
    FOREGROUND_SERVICE permission.
    This is a normal permission, so the system automatically grants it.
    https://developer.android.com/about/versions/pie/android-9.0-migration#tya
    -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <!--
    La permission FOREGROUND_SERVICE serve per indicare all'OS che terminare il processo avrebbe
    un effetto negativo per l'utente. Va chiamato anche il metodo startForeground.
    Permission necessaria da API level >= 28
    -->


    <!--Per evitare, dopo aver chiamato l'opportuno metodo, che il gestore del risparmio energetico
    tolga la CPU e interrompa la musica-->
    <uses-permission android:name="android.permission.WAKE_LOCK" />

    <!--TODO serve??-->
    <permission android:name="android.permission.MEDIA_CONTENT_CONTROL" />



    <application
        android:name="com.android.notificationexpo.NotificationExpoApplication"
        android:allowBackup="false"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.MasterDetailFlow">
        <activity
            android:name="com.android.notificationexpo.ItemListActivity"
            android:label="@string/app_name"
            android:launchMode="singleTop"
            android:theme="@style/Theme.MasterDetailFlow.NoActionBar">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
        <activity
            android:name="com.android.notificationexpo.SettingsActivity"
            android:label="@string/app_name"
            android:theme="@style/Theme.MasterDetailFlow">
        </activity>
        <activity
            android:name="com.android.notificationexpo.CreditsActivity"
            android:label="@string/app_name"
            android:theme="@style/Theme.MasterDetailFlow">
        </activity>
        <activity
            android:name="com.android.notificationexpo.WelcomeActivity"
            android:label="@string/app_name"
            android:theme="@style/Theme.MasterDetailFlow">
        </activity>
        <activity
            android:name="com.android.notificationexpo.ItemDetailActivity"
            android:label="@string/title_item_detail"
            android:parentActivityName="com.android.notificationexpo.ItemListActivity"
            android:launchMode="singleTop"
            android:theme="@style/Theme.MasterDetailFlow.NoActionBar">
            <!-- Serve per pulsante che torna indietro nella toolbar -->
            <meta-data
                android:name="android.support.PARENT_ACTIVITY"
                android:value="com.android.notificationexpo.ItemListActivity" />
        </activity>



        <!--
        Aggiungo il BroadcastReceiver che si attiva quando l'AlarmManger termina.
        Questo BoradcastReceiver, essendo dichiarato qui, sarà attivo anche ad app chiusa
        -->
        <receiver
            android:name="com.android.notificationexpo.AlarmManagerReceiver"
            android:exported="false"/>
            <!--
            L'attrivuto exported = false serve in quanto questro BroadcastReceiver potrebbe ricevere
            intent espliciti da altre app e in questo modo ci proteggiamo accettando broadcast
            provenienti solo dall'app.
            https://developer.android.com/guide/components/broadcasts#security-and-best-practices
            Nota: Il broadcast viene ricevuto anche se fatto partire da AlarmManager, purchè l'intent
            sia stato creato dalla nostra app

            Nota: Questo BoradcastReceiver viene chiamato solo con un intent esplicito.
            Per gli intent espliciti (come nel nostro caso) l'intent è sempre recapitato,
            indipendentemente dagli intent-filter
            https://developer.android.com/guide/components/intents-filters.html#Receiving
            -->


        <!--
        Aggiungo il BroadcastReceiver che permette all'app di aggiungere un messaggio al Database e
        di visualizzare le notifiche.
        Questo BoradcastReceiver, essendo dichiarato qui, sarà attivo anche ad app chiusa.
        -->
        <receiver
            android:name="com.android.notificationexpo.AlarmManagerReceiverAlwaysOn"
            android:permission="com.android.NotificationsExpo.PRIVATE"
            android:exported="false">
            <!--
            L'attrivuto exported = false serve in quanto questro BroadcastReceiver potrebbe ricevere
            intent espliciti da altre app e in questo modo ci proteggiamo accettando broadcast
            provenienti solo dall'app.
            https://developer.android.com/guide/components/broadcasts#security-and-best-practices
            Nota: Il broadcast viene ricevuto anche se fatto partire da AlarmManager, purchè l'intent
            sia stato creato dalla nostra app

            Questo broadcast è in ascolto di intent implicti. Utilizziamo gli intent impliciti in quanto
            con quelli espliciti possiamo notificare solo un BoradcastReceiver, mentre noi dobbiamo
            notificarne o due o uno a seocnda dei casi (c'è un receiver attivo a runtime).
            Per via delle restrizioni di Android ai broadcast impliciti, se dichiaramo il boradcast nel
            manifest senza un adeguata permission, il broadcast non verrà recapitato.
            Nello specifico, con il meccanismo delle permissions di livello "signature"
            si possono riceve intent solo da app provenienti dallo stesso sviluppatore.
            -->
            <intent-filter android:priority="-999">
                <!--Assegnamo la priorià più bassa possibile, in modo che in un ordereed broadcast
                questo receiver sia l'ultimo ad essere chiamato-->
                <action android:name="com.android.NotificationsExpo.SHOW_NOTIFICATION"/>
            </intent-filter>
        </receiver>
        <receiver android:name="com.android.notificationexpo.CustomNotificationReceiver" />
        <receiver android:name="com.android.notificationexpo.QuickActionNotificationReceiver" />



        <!-- Il service per il player audio in background-->
        <service
            android:name="com.android.notificationexpo.PlayerService"
            android:enabled="true"
            android:exported="false" />


        <!-- Per ricevere i broadcast dai pulsanti mostrati nella notifica del player audio-->
        <receiver
            android:name="com.android.notificationexpo.AudioNotificationReceiver"
            android:exported="false">
            <intent-filter>
                <action android:name="RESUME_ACTION"/>
                <action android:name="STOP_ACTION"/>
                <action android:name="CANCEL_ACTION"/>
            </intent-filter>
        </receiver>


    </application>

</manifest>
